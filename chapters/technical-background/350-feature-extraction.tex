\section{Feature Extraction}

\subsection{Selection of Features}

\subsection{Basic Features}
Height, Width, Centroid

\subsection{Vertical and Horizontal Holes}

\subsection{Raw Moments}

Can be used to calculate the centroid and area

\subsection{Centralised Moments}
\todo[inline]{Centralised Moments - Scikit Image References}

% http://en.wikipedia.org/wiki/Image_moments#Raw_moments
%Area (for binary images) or sum of grey level (for greytone images): M00
% Centroid: { x, y } = {M10/M00, M01/M00 }

\subsection{Normalised Central Moments}
\todo[inline]{Normalised Central Moments - Scikit Image References}

\subsection{Run Length Encoding}
\label{sec:tb-rle}

\acrfull{RLE} is something which is regularly mentioned in regard to OMR, it involves taking a pixel based image and converting what would be a huge amount of information into a more compact format by establishing ``runs'' of identical pixels which are in a contiguous block.

For a two dimensional binary image a run of pixels can be represented by it's row, column, value and run length \parencite[p. 27-28]{burger2009principles} as seen in \cref{table:rle-2d}

\begin{table}[h]

    \begin{tabularx}{\textwidth}{ X | X }
        \toprule
        Example & RLE $(\textbf{row}, \textbf{column}, \textbf{value}, \textbf{length})$\\
        \midrule

        $$\begin{bmatrix}
        1 & 2 & 2 & 3  \\
        3 & 3 & 3 & 1  \\
        1 & 1 & 5 & 5  \\
        5 & 5 & 2 & 2
        \end{bmatrix}$$

        &
        {[} (0, 0, 1, 1), (0, 1, 2, 2), (0, 3, 3, 1), \newline
        (1, 0, 3, 3), (1, 3, 1, 1), (2, 0, 1, 2), \newline
        (2, 2, 5, 2), (3, 0, 5, 2), (3, 2, 5, 2) {]} \\
        \ & \ \\
    \bottomrule
    \end{tabularx}

    \label{table:rle-2d}
    \caption{2D Greyscale Image}
\end{table}


\begin{table}[h]
    \begin{tabularx}{\textwidth}{ X | X }
        \toprule
        Example & RLE $(\textbf{value}, \textbf{length})$\\
        \midrule

        {[} 1, 2, 2, 3, 3, 3, 3, 1, 1, 1, 5, 5, 5, 5, 2, 2 {]}
        &
        {[} $(1, 1)$,
        $(2, 2)$,
        $(3, 4)$,
        $(1, 3)$,
        $(5, 4)$,
        $(2, 2)$ {]} \\
    \bottomrule
    \end{tabularx}

    \label{table:rle-1d}
    \caption{1D Flattened Greyscale Image}
\end{table}

\begin{table}[h]
    \begin{tabularx}{\textwidth}{ X | X }
        \toprule
        Example & RLE $\langle \textbf{value}, \textbf{length} \rangle$\\
        \midrule

        {[} 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1 {]}
        &
        {[} 0, 3, 3, 2, 4 {]} (first bit sets ordering)\newline
        {[} 3, 3, 2, 4 {]} (assuming initial bit is 0) \\
    \bottomrule
    \end{tabularx}

    \label{table:rle-1d-binary}
    \caption{1D Flattened Binary Image}
\end{table}

If you then reshape this 2D image into a one dimensional array (retrieving and reshaping it to it's 2D representation later), you can remove 50\% of the compressed data (row and column) as seen in \cref{table:rle-1d}

If we are using binary data we can simplify this further, simply tracking the initial bit, then recording runs of alternating values as seen in \cref{table-1d-binary}, we can simplify this further with the additional assumption \parencite{fujinaga1996adaptive} that the sequence will start with a 0, removing the need for the initial bit. If the sequence begins with a 1 we just start with an entry of length 0. Since a lot of musical entities don't touch the top left corner, this is the implementation I have used.
